<DOCTYPE html>
<head>
	<script src="glMatrix-0.9.5.min.js"></script>
    <script src="webgl-utils.js"></script>	
	<!--Define vertex and fragment shader-->
	<script id="shader-fs" type="x-shader/x-fragment">
	  precision mediump float;
	  
	  varying vec4 vColour;
	 
	 void main(void) {
//		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); old code
		gl_FragColor = vColour; //get the varying from the vertex shader (vColour is now the input.)
	  }
	</script>
	<script id="shader-vs" type="x-shader/x-vertex">
	  attribute vec3 aVertexPosition; //input
      attribute vec4 aVertexColour; //input

	  uniform mat4 uMVMatrix;
	  uniform mat4 uPMatrix;
	
	  varying vec4 vColour;//the output

	  void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); //a varying value
		vColour = aVertexColour; //output varying value 
	  }
	</script>
	<script>


	 var gl; //gl context
	 var mvMatrix = mat4.create();
	 var pMatrix = mat4.create();//creates matrices
     var mvMatrixStack = [];//A Stack of matrices
	 
	 
	//variables for buffers	
	 var triangleVertexPositionBuffer;
	 var triangleVertexColorBuffer;
	 var squareVertexPositionBuffer;//memory
     var squareVertexColorBuffer;

	 //animation for rotation
	 
	  var rPyramid = 0;
      var rCube = 0; 
	 
	 // var rTri = 0;
	 // var rSquare = 0;
	  var lastTime = 0;
	 
	 	 
	  function initGL(canvas) {
	  //Error Handling to initialise GL context
		try {
		  gl = canvas.getContext("experimental-webgl");
		  gl.viewportWidth = canvas.width;
		  gl.viewportHeight = canvas.height;
		} catch(e) {
		}
		if (!gl) {
		  alert("Could not initialise WebGL, sorry :-( ");
		}
	  }//initGL

	  function initShaders() {
	  // Load the shaders, gets “fragment and vertex shader”, then adds them to a Shader program.  
		var fragmentShader = getShader(gl, "shader-fs");
		var vertexShader = getShader(gl, "shader-vs");

		shaderProgram = gl.createProgram();// Creates a Shader Program
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);//adds v+f to the program
		gl.linkProgram(shaderProgram);// links them together

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		//error handling
		  alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);
		
		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");//references a “attribute”, kept within a program called vertexPositionAttribute
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute); 

        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColour");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);		
		
		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix"); //projection matrix
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix"); //model-view matrix

		
		
	  }//initShaders

	  function getShader(gl, id) {
	//Check the document, if the ID matches the parameter

		  var shaderScript = document.getElementById(id);
		  if (!shaderScript) {
			  return null;
		  }

		  var str = "";
		  var k = shaderScript.firstChild;
		  while (k) {
			  if (k.nodeType == 3)
				  str += k.textContent;
			  k = k.nextSibling;
		  }

		  var shader;
		  
		   //creates either a fragment or a vertex shader based on its type 
		  if (shaderScript.type == "x-shader/x-fragment") {
			  shader = gl.createShader(gl.FRAGMENT_SHADER);
		  } else if (shaderScript.type == "x-shader/x-vertex") {
			  shader = gl.createShader(gl.VERTEX_SHADER);
		  } else {
			  return null;
		  }
		  
		  gl.shaderSource(shader, str);// Location of shader
		  gl.compileShader(shader);//compile the shader

		  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		  //Error handling
			  alert(gl.getShaderInfoLog(shader));
			  return null;
		  }

		  return shader;
	  }//getShader

	  
	var pyramidVertexPositionBuffer;
    var pyramidVertexColorBuffer;
    var cubeVertexPositionBuffer;
    var cubeVertexColorBuffer;
    var cubeVertexIndexBuffer;  
	  
	  
	  function initBuffers(){
		//Loads buffers
		pyramidVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
    var vertices = [
        // Front face
         0.0,  1.0,  0.0,
        -1.0, -1.0,  1.0,
         1.0, -1.0,  1.0,
        // Right face
         0.0,  1.0,  0.0,
         1.0, -1.0,  1.0,
         1.0, -1.0, -1.0,
        // Back face
         0.0,  1.0,  0.0,
         1.0, -1.0, -1.0,
        -1.0, -1.0, -1.0,
        // Left face
         0.0,  1.0,  0.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0,  1.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    pyramidVertexPositionBuffer.itemSize = 3;
    pyramidVertexPositionBuffer.numItems = 12;
	
	
//<pyr-colour>
    pyramidVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
    var colors = [
        // Front face
        1.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        // Right face
        1.0, 0.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        // Back face
        1.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        // Left face
        1.0, 0.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        0.0, 1.0, 0.0, 1.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    pyramidVertexColorBuffer.itemSize = 4;
    pyramidVertexColorBuffer.numItems = 12;
//</pyr-colour>



//<cubevertex>
    cubeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    vertices = [
      // Front face
      -1.0, -1.0,  1.0,
       1.0, -1.0,  1.0,
       1.0,  1.0,  1.0,
      -1.0,  1.0,  1.0,

      // Back face
      -1.0, -1.0, -1.0,
      -1.0,  1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0, -1.0, -1.0,

      // Top face
      -1.0,  1.0, -1.0,
      -1.0,  1.0,  1.0,
       1.0,  1.0,  1.0,
       1.0,  1.0, -1.0,

      // Bottom face
      -1.0, -1.0, -1.0,
       1.0, -1.0, -1.0,
       1.0, -1.0,  1.0,
      -1.0, -1.0,  1.0,

      // Right face
       1.0, -1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0,  1.0,  1.0,
       1.0, -1.0,  1.0,

      // Left face
      -1.0, -1.0, -1.0,
      -1.0, -1.0,  1.0,
      -1.0,  1.0,  1.0,
      -1.0,  1.0, -1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    cubeVertexPositionBuffer.itemSize = 3;
    cubeVertexPositionBuffer.numItems = 24;
	
	
    cubeVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
    colors = [
      [1.0, 0.0, 0.0, 1.0],     // Front face
      [1.0, 1.0, 0.0, 1.0],     // Back face
      [0.0, 1.0, 0.0, 1.0],     // Top face
      [1.0, 0.5, 0.5, 1.0],     // Bottom face
      [1.0, 0.0, 1.0, 1.0],     // Right face
      [0.0, 0.0, 1.0, 1.0],     // Left face
    ];
    var unpackedColors = [];
    for (var i in colors) {
      var color = colors[i];
      for (var j=0; j < 4; j++) {
        unpackedColors = unpackedColors.concat(color);
      }
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
    cubeVertexColorBuffer.itemSize = 4;
    cubeVertexColorBuffer.numItems = 24;



    cubeVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    var cubeVertexIndices = [
      0, 1, 2,      0, 2, 3,    // Front face
      4, 5, 6,      4, 6, 7,    // Back face
      8, 9, 10,     8, 10, 11,  // Top face
      12, 13, 14,   12, 14, 15, // Bottom face
      16, 17, 18,   16, 18, 19, // Right face
      20, 21, 22,   20, 22, 23  // Left face
    ]
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
    cubeVertexIndexBuffer.itemSize = 1;
    cubeVertexIndexBuffer.numItems = 36;










	
	

//</cubevertex>




		
	  }//initBuffers
	  
	  function drawScene(){

		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		mat4.identity(mvMatrix);
		
		//<triangle>
		mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);	
		
		//animation
		mvPushMatrix();
		mat4.rotate(mvMatrix, degToRad(rPyramid), [0, 1, 0]);
			

		gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pyramidVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			//add colour
		gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pyramidVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

		setMatrixUniforms();
		gl.drawArrays(gl.TRIANGLES, 0, pyramidVertexPositionBuffer.numItems);

		mvPopMatrix();
		//</triangle>
		
		//<square>
		mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
		
		//animate
		mvPushMatrix();
		mat4.rotate(mvMatrix, degToRad(rCube), [1, 0, 0]);
			
		
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		
		//add colour
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

//added element array data
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

		mvPopMatrix();
		
		//</square>		
	}//drawScene
	  
	  function setMatrixUniforms() {
	  //sends matrices from JS into the GL world
		gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
		gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	  }
	  
	  function webGLStart(){
		var canvas = document.getElementById("canvas");
		initGL(canvas);
		initShaders();
		initBuffers();
		gl.clearColor(0.0, 0.0, 0.0, 1.0);
		gl.enable(gl.DEPTH_TEST);

	    tick();
		//drawScene();
	  }//WebGLStart	 

	  function tick() {
		requestAnimFrame(tick);
		drawScene();
		animate();
	  }//tick	
	  
	 //The rotation of objects is based on the elapsed time from when this method was last called.
	  function animate() {
		var timeNow = new Date().getTime();
		if (lastTime != 0) {
		  var elapsed = timeNow - lastTime;

		  rPyramid  += (90 * elapsed) / 1000.0;
		  rCube  += (75 * elapsed) / 1000.0;
		}
		lastTime = timeNow;
	  }//animate

	  function mvPushMatrix() {
		var copy = mat4.create();
		mat4.set(mvMatrix, copy);
		mvMatrixStack.push(copy);
	  }//mvPushMatrix

	  function mvPopMatrix() {
		if (mvMatrixStack.length == 0) {
		  throw "Invalid popMatrix!";
		}
		mvMatrix = mvMatrixStack.pop();
	  }//mvPopMatrix
	  
	  function degToRad(degrees) {
        return degrees * Math.PI / 180;
      }//degToRad
	  
	  

			function addCubes() {

	//			for(var i = 0; i < ppp; i++) {
//Create cube 

//Add cube to Array

//Define random postion within scene
	//			}

			}



			function onTButtonDown(event) {
				//if(button.Down == 'T') 
					//{
					//addCubes();
				//}
			}











	</script>
</head>
<body onload="webGLStart();">
	  <canvas id="canvas" style="border: 3px solid blue;" width="500" height="500"></canvas>
	  <br/>
</body>
</html>
