    <html>
<head>
	<meta charset="UTF-8">        
            <script id="vertex" type="x-shader">
				attribute vec3 vertexPosition;
				
				uniform mat4 modelViewMatrix;
				uniform mat4 perspectiveMatrix;

				void main(void) {
				gl_Position = perspectiveMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
				}
			</script>  
            <script id="fragment" type="x-shader">
				void main(void) {
				gl_FragColor = vec4(0.6, 0.0, 0.0, 1.0);
				}
			</script>        
            <script type="text/javascript">
				function loadScene()
				{
					var canvas = document.getElementById("webGLCanvas");
					var gl = canvas.getContext("experimental-webgl");
					if(!gl)
					{
						alert("There's no WebGL context available.");
						return;
					}
					gl.viewport(0, 0, canvas.width, canvas.height);
					
					
					
					
					var vertexShaderScript = document.getElementById("shader-vs");
					var vertexShader = gl.createShader(gl.VERTEX_SHADER);
					gl.shaderSource(vertexShader, vertexShaderScript.text);
					gl.compileShader(vertexShader);
					if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
						alert("Couldn't compile the vertex shader");
						gl.deleteShader(vertexShader);
					return;
					}
					   


					var fragmentShaderScript = document.getElementById("shader-fs");
					var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
					gl.shaderSource(fragmentShader, fragmentShaderScript.text);
					gl.compileShader(fragmentShader);
					if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
						alert("Couldn't compile the fragment shader");
						gl.deleteShader(fragmentShader);
						return;
					}


					gl.program = gl.createProgram();
					gl.attachShader(gl.program, vertexShader);
					gl.attachShader(gl.program, fragmentShader);
					gl.linkProgram(gl.program);
					if (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {
						alert("Unable to initialise shaders");
						gl.deleteProgram(gl.program);
						gl.deleteProgram(vertexShader);
						gl.deleteProgram(fragmentShader);
						return;
					}
					gl.useProgram(gl.program);
					
					
					
					var vertexPosition = gl.getAttribLocation(gl.program, "vertexPosition");
					gl.enableVertexAttribArray(vertexPosition);


					
					gl.clearColor(0.0, 0.0, 0.0, 1.0);
					gl.clearDepth(1.0);
					gl.enable(gl.DEPTH_TEST);
					gl.depthFunc(gl.LEQUAL);

					var vertexBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
					var vertices = new Float32Array([
					0.0, 1.0, 4.0,
					-1.0, -1.0, 4.0,
					1.0, -1.0, 4.0
					]);

					gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

					var fieldOfView = 30.0;
					var aspectRatio = canvas.width / canvas.height;
					var nearPlane = 1.0;
					var farPlane = 10000.0;
					var top = nearPlane * Math.tan(fieldOfView * Math.PI / 360.0);
					var bottom = -top;
					var right = top * aspectRatio;
					var left = -right;

						var a = (right + left) / (right - left);
						var b = (top + bottom) / (top - bottom);
						var c = (farPlane + nearPlane) / (farPlane - nearPlane);
						var d = (2 * farPlane * nearPlane) / (farPlane - nearPlane);
						var x = (2 * nearPlane) / (right - left);
						var y = (2 * nearPlane) / (top - bottom);
						var perspectiveMatrix = [
						x, 0, a, 0,
						0, y, b, 0,
						0, 0, c, d,
						0, 0, -1, 0
						];
					   
					  
						var modelViewMatrix = [
						1, 0, 0, 0,
						0, 1, 0, 0,
						0, 0, 1, 0,
						0, 0, 0, 1
						];
					   
					   
						var vertexPosAttribLocation = gl.getAttribLocation(gl.program, "vertexPosition");
						gl.vertexAttribPointer(vertexPosAttribLocation, 3.0, gl.FLOAT, false, 0, 0);
						var uModelViewMatrix = gl.getUniformLocation(gl.program, "modelViewMatrix");
						var uPerspectiveMatrix = gl.getUniformLocation(gl.program, "perspectiveMatrix");
						gl.uniformMatrix4fv(uModelViewMatrix, false, new Float32Array(perspectiveMatrix));
						gl.uniformMatrix4fv(uPerspectiveMatrix, false, new Float32Array(modelViewMatrix));
						
						
						//gl.uniformMatrix4fv(uModelViewMatrix, false, new Float32Array(modelViewMatrix));
						//gl.uniformMatrix4fv(uPerspectiveMatrix, false, new Float32Array(perspectiveMatrix));	
						

						// Draw the triangles in the vertex buffer. The first parameter specifies what
						// drawing mode to use. This can be POINTS, LINE_STRIP, LINE_LOOP, LINES, TRIANGLE_STRIP,
						// TRIANGLE_FAN and TRIANGLES
						gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 3.0);
						gl.flush();
					   
					   				   
				}//loadScene


     		</script>
    </head>
    <body>
            <canvas id="webGLCanvas" width="500" height="500"></canvas>
    </body>
    </html>