<DOCTYPE html>
<head>
	<meta charset="UTF-8"> 
	<script src="glMatrix-0.9.5.min.js"></script>
    <script src="webgl-utils.js"></script>	
	<!--Define vertex and fragment shader-->
	<script id="shader-fs" type="x-shader/x-fragment">
	  precision mediump float;
	  
	  varying vec2 vTextureCoord;

  uniform sampler2D uSampler;
	 
	 void main(void) {
//		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); old code
//		gl_FragColor = vColour; //get the varying from the vertex shader (vColour is now the input.)
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));	 
	 }
	  
	</script>
	
	
	<script id="shader-vs" type="x-shader/x-vertex">
	  attribute vec3 aVertexPosition; //input
      attribute vec2 aTextureCoord; //input

	  uniform mat4 uMVMatrix;
	  uniform mat4 uPMatrix;
	
	  varying vec2 vTextureCoord;//the output

	  void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); //a varying value
		vTextureCoord = aTextureCoord; //output varying value 
	  }
	</script>
	<script>


	 var gl; //gl context
	 var mvMatrix = mat4.create();
	 var pMatrix = mat4.create();//creates matrices
     var mvMatrixStack = [];//A Stack of matrices
	 
	 
	//variables for buffers	
	 var triangleVertexPositionBuffer;
	 var triangleVertexColorBuffer;
	 var squareVertexPositionBuffer;//memory
     var squareVertexColorBuffer;

	 //animation for rotation
	 
	  var rPyramid = 0;
      var rCube = 0; 
	 
	 // var rTri = 0;
	 // var rSquare = 0;
	  var lastTime = 0;
	 
	 	 
	  function initGL(canvas) {
	  //Error Handling to initialise GL context
		try {
		  gl = canvas.getContext("experimental-webgl");
		  gl.viewportWidth = canvas.width;
		  gl.viewportHeight = canvas.height;
		} catch(e) {
		}
		if (!gl) {
		  alert("Could not initialise WebGL, sorry :-( ");
		}
	  }//initGL

	  function initShaders() {
	  // Load the shaders, gets “fragment and vertex shader”, then adds them to a Shader program.  
		var fragmentShader = getShader(gl, "shader-fs");
		var vertexShader = getShader(gl, "shader-vs");

		shaderProgram = gl.createProgram();// Creates a Shader Program
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);//adds v+f to the program
		gl.linkProgram(shaderProgram);// links them together

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		//error handling
		  alert("Could not initialise shaders");
		}
		

		gl.useProgram(shaderProgram);
		
		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");//references a “attribute”, kept within a program called vertexPositionAttribute
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute); 

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);		
		
		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix"); //projection matrix
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix"); //model-view matrix
		
		shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
		
	  }//initShaders
	  
	  


	  function getShader(gl, id) {
	//Check the document, if the ID matches the parameter

		  var shaderScript = document.getElementById(id);
		  if (!shaderScript) {
			  return null;
		  }

		  var str = "";
		  var k = shaderScript.firstChild;
		  while (k) {
			  if (k.nodeType == 3)
				  str += k.textContent;
			  k = k.nextSibling;
		  }

		  var shader;
		  
		   //creates either a fragment or a vertex shader based on its type 
		  if (shaderScript.type == "x-shader/x-fragment") {
			  shader = gl.createShader(gl.FRAGMENT_SHADER);
		  } else if (shaderScript.type == "x-shader/x-vertex") {
			  shader = gl.createShader(gl.VERTEX_SHADER);
		  } else {
			  return null;
		  }
		  
		  gl.shaderSource(shader, str);// Location of shader
		  gl.compileShader(shader);//compile the shader

		  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		  //Error handling
			  alert(gl.getShaderInfoLog(shader));
			  console.log('Shader log : ' + shader);// compiled successfully
			  
			  
			  
			  return null;
		  }

		  return shader;
	  }//getShader

	  
	var pyramidVertexPositionBuffer;
    var pyramidVertexColorBuffer;
    var cubeVertexPositionBuffer;
    var cubeVertexColorBuffer;
    var cubeVertexIndexBuffer;  
	  
	  
	  function initBuffers(){
		cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,
            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,
            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,
            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,
            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,
            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 24;
		
//<Normals>
		   cubeVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
    var vertexNormals = [
      // Front face
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,

      // Back face
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,

      // Top face
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,

      // Bottom face
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,

      // Right face
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,

      // Left face
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
    cubeVertexNormalBuffer.itemSize = 3;
    cubeVertexNormalBuffer.numItems = 24;

//</Normals>		
		
        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        var textureCoords = [
          // Front face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          // Back face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          // Top face
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          // Bottom face
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          // Right face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          // Left face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 24;
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;
	  }//initBuffers
	  
	  
	  
  var xRot = 0;
  var xSpeed = 0;

  var yRot = 0;
  var ySpeed = 0;

  var z = -5.0;

  var filter = 0;

  
	  function drawScene(){

        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, [0.0, 0.0, z]);
		
        mat4.rotate(mvMatrix, degToRad(xRot), [1, 0, 0]);
        mat4.rotate(mvMatrix, degToRad(yRot), [0, 1, 0]);
		
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.activeTexture(gl.TEXTURE0);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		
		gl.bindTexture(gl.TEXTURE_2D, crateTexture);
		
		 var lighting = document.getElementById("lighting").checked;
    gl.uniform1i(shaderProgram.useLightingUniform, lighting);
		
    if (lighting) {
      gl.uniform3f(
        shaderProgram.ambientColorUniform,
        parseFloat(document.getElementById("ambientR").value),
        parseFloat(document.getElementById("ambientG").value),
        parseFloat(document.getElementById("ambientB").value)
      );
		
      var lightingDirection = [
        parseFloat(document.getElementById("lightDirectionX").value),
        parseFloat(document.getElementById("lightDirectionY").value),
        parseFloat(document.getElementById("lightDirectionZ").value)
      ];
	  
      var adjustedLD = vec3.create();
      vec3.normalize(lightingDirection, adjustedLD);
      vec3.scale(adjustedLD, -1);
      gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
		
      gl.uniform3f(
        shaderProgram.directionalColorUniform,
        parseFloat(document.getElementById("directionalR").value),
        parseFloat(document.getElementById("directionalG").value),
        parseFloat(document.getElementById("directionalB").value)
      );
		
		
		}//if lighting
		
        gl.uniform1i(shaderProgram.samplerUniform, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);




 }//drawScene
	  
	  function setMatrixUniforms() {
	  //sends matrices from JS into the GL world
		gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
		gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	  }
	  
	  function webGLStart(){
		var canvas = document.getElementById("canvas");
		initGL(canvas);
		initShaders();
		initBuffers();
		initTexture();
		gl.clearColor(0.0, 0.0, 0.0, 1.0);
		gl.enable(gl.DEPTH_TEST);
		
		document.onkeydown = handleKeyDown;
		document.onkeyup = handleKeyUp;

	    tick();
		//drawScene();
	  }//WebGLStart	 

 var crateTextures = Array();

  function initTexture() {
    var crateImage = new Image();

    for (var i=0; i < 3; i++) {
      var texture = gl.createTexture();
      texture.image = crateImage;
      crateTextures.push(texture);
    }

    crateImage.onload = function() {
      handleLoadedTexture(crateTextures)
    }
    crateImage.src = "crate.gif";
  }


      function handleLoadedTexture(textures) {
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, textures[0]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[0].image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, textures[1]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[1].image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, textures[2]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[2].image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
	  
	  function tick() {
		requestAnimFrame(tick);
		 handleKeys();
		drawScene();
		animate();
	  }//tick	
	  
	 //The rotation of objects is based on the elapsed time from when this method was last called.
	  function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
     xRot += (xSpeed * elapsed) / 1000.0;
      yRot += (ySpeed * elapsed) / 1000.0;
        }
        lastTime = timeNow;
    }//animate

	  function mvPushMatrix() {
		var copy = mat4.create();
		mat4.set(mvMatrix, copy);
		mvMatrixStack.push(copy);
	  }//mvPushMatrix

	  function mvPopMatrix() {
		if (mvMatrixStack.length == 0) {
		  throw "Invalid popMatrix!";
		}
		mvMatrix = mvMatrixStack.pop();
	  }//mvPopMatrix
	  
	  function degToRad(degrees) {
        return degrees * Math.PI / 180;
      }//degToRad
	    
	  function addCubes() {

	//			for(var i = 0; i < ppp; i++) {
//Create cube 

//Add cube to Array

//Define random postion within scene
	//			}

		}//addCubes

	  function onTButtonDown(event) {
				//if(button.Down == 'T') 
					//{
					//addCubes();
				//}
		}


  var currentlyPressedKeys = {};

  function handleKeyDown(event) {
    currentlyPressedKeys[event.keyCode] = true;

    if (String.fromCharCode(event.keyCode) == "F") {
      filter += 1;
      if (filter == 3) {
        filter = 0;
      }
    }
  }

  function handleKeyUp(event) {
    currentlyPressedKeys[event.keyCode] = false;
  }

  function handleKeys() {
    if (currentlyPressedKeys[33]) {
      // Page Up
      z -= 0.05;
    }
    if (currentlyPressedKeys[34]) {
      // Page Down
      z += 0.05;
    }
    if (currentlyPressedKeys[37]) {
      // Left cursor key
      ySpeed -= 1;
    }
    if (currentlyPressedKeys[39]) {
      // Right cursor key
      ySpeed += 1;
    }
    if (currentlyPressedKeys[38]) {
      // Up cursor key
      xSpeed -= 1;
    }
    if (currentlyPressedKeys[40]) {
      // Down cursor key
      xSpeed += 1;
    }
  }




	</script>
</head>
<body onload="webGLStart();">
	  <canvas id="canvas" style="border: 3px solid blue;" width="500" height="500"></canvas>
	  <br/>
</body>
</html>
